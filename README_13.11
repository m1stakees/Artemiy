1 ПУНКТ)
Вариант 10. Жадный алгоритм для выбора задач (Task Selection)
Задача: реализовать жадный алгоритм для выбора максимального количества
непересекающихся задач (интервалов).

2 ПУНКТ)
Объяснение алгоритма.
Принцип работы жадного алгоритма для выбора задач.
Основная идея алгоритма заключается в последовательном выборе максимального количества непересекающихся задач. Алгоритм делает локально оптимальный выбор на каждом шаге, что приводит к глобально оптимальному решению.

Этапы работы алгоритма

Сортировка задач по времени окончания.
Все задачи упорядочиваются по возрастанию времени окончания.
Это позволяет сначала рассмотреть задачи, которые заканчиваются раньше.

def select_tasks(tasks):
    # Сортируем задачи по времени окончания
    sorted_tasks = sorted(tasks, key=lambda x: x[1])

Здесь происходит сортировка всех задач по времени их окончания. Это ключевой момент алгоритма, так как именно благодаря сортировке мы можем гарантировать оптимальность решения.

Инициализация переменных
Создается пустой список для выбранных задач
Устанавливается начальное время окончания последней выбранной задачи (0)
Основной процесс выбора
Алгоритм последовательно просматривает отсортированные задачи
Для каждой задачи проверяется условие: время начала ≥ времени окончания последней выбранной задачи
Если условие выполняется, задача добавляется в результат

selected = []  # Список выбранных задач
last_end = 0   # Время окончания последней выбранной задачи

for start, end in sorted_tasks:
    if start >= last_end:  # Проверяем непересечение
        selected.append((start, end))  # Добавляем в результат
        last_end = end  # Обновляем время окончания

Берём первую задачу (1,3):
start (1) >= last_end (0) → условие выполняется
Добавляем в результат
last_end становится равным 3

Следующая задача (2,5):
start (2) < last_end (3) → условие НЕ выполняется
Пропускаем эту задачу

Задача (4,6):
start (4) >= last_end (3) → условие выполняется
Добавляем в результат
last_end становится равным 6


3 ПУНКТ) Временная сложность алгоритма.
После вывода ИИ готового кода для выполнения алгоритма для выбора задач (Task Selection),  можно просчитать временную сложность.
Временная сложность имеет вид: O(n log n).

4 ПУНКТ) Объяснение временной сложности:
После просчета временной сложности, постараемся понять, почему именно она имеет такой вид.
Временная сложность алгоритма определяется двумя основными факторами:
Сортировка задач занимает O(n log n) времени, где n — количество задач. Это самая затратная часть алгоритма.
Проход по отсортированным задачам требует O(n) операций, так как:

Нужно просмотреть каждую задачу один раз.
Для каждой задачи выполняется простое сравнение.
При необходимости происходит добавление в результат.
Итоговая сложность алгоритма — O(n log n), так как:

Сложность определяется наиболее медленной операцией.
Сортировка работает медленнее, чем проход по списку.
Остальные операции выполняются за константное время.

5 ПУНКТ) Ответ на контрольный вопрос.
Чем эвристические алгоритмы отличаются от приближенных? Приведите примеры.

Приближенные алгоритмы дают гарантированную точность решения относительно оптимального. Например:
Жадный алгоритм для вершинного покрытия (ошибка не более 2 раз от оптимального)
Алгоритм Кристофидеса для TSP (ошибка не более 1.5 раз)
Эвристические алгоритмы не дают никаких гарантий качества решения. Примеры:
Имитация отжига
Генетические алгоритмы
Табу-поиск

Основные отличия:

Гарантии результата:
Приближенные — имеют математическое доказательство точности
Эвристические — основаны на практическом опыте

Скорость работы:
Приближенные — обычно медленнее, но стабильнее
Эвристические — быстрее, но результат может сильно варьироваться

Применение:
Приближенные — когда нужна гарантированная точность
Эвристические — когда требуется быстрое “достаточно хорошее” решение

Ресурсы:
Приближенные — требуют больше памяти и времени
Эвристические — экономнее используют ресурсы

Пример: для задачи коммивояжера:
Рассмотрим пример задачи коммивояжёра (TSP) для иллюстрации разницы между приближённым и эвристическим алгоритмами.

Приближённый алгоритм (алгоритм Кристофидеса)
Гарантирует решение не хуже 1.5 от оптимального:

Строит минимальное остовное дерево
Находит совершенное паросочетание минимального веса для вершин нечётной степени
Объединяет эти структуры
Преобразует в маршрут

Пример работы:

Вход: граф с 5 городами и весами рёбер
Выход: маршрут длиной не более 1.5 * OPT
Эвристический алгоритм (имитация отжига)
Не гарантирует конкретной близости к оптимальному решению:

Начинает с произвольного маршрута
Постепенно улучшает его
Может застрять в локальном оптимуме
Результат зависит от параметров

Пример работы:

Вход: тот же граф
Выход: маршрут хорошей длины, но без гарантий
Сравнение на конкретном примере
Исходные данные:

5 городов

Матрица расстояний:
A-B: 10
A-C: 15
A-D: 20
A-E: 25
B-C: 35
B-D: 25
B-E: 30
C-D: 30
C-E: 20
D-E: 15

Результаты:

Приближённый алгоритм:
Найдёт маршрут длиной ≤ 1.5 * OPT
Например, A-B-D-E-C-A длиной 105 (если OPT = 70)
Эвристический алгоритм:
Может найти маршрут длиной 90
Или хуже — длиной 120
Зависит от начальных параметров

Ключевые отличия:

Гарантии качества:
Приближённый: всегда ≤ 1.5 * OPT
Эвристический: может быть как очень близко, так и далеко от OPT
Вычислительная сложность:

Приближённый: O(n³)
Эвристический: зависит от настроек, может быть O(k * n²)

Применимость:
Приближённый: когда нужна гарантия качества
Эвристический: когда важна скорость и приемлемое решение

Таким образом, выбор между этими подходами зависит от конкретной задачи и требований к решению.

