Деревья и Графы: Основные понятия

Что такое дерево?

Дерево — это связный граф, не содержащий циклов. Ключевые свойства дерева:

· Между любыми двумя вершинами существует ровно один путь.
· Оно состоит из конечного числа вершин и рёбер.

Часто деревья представляют в виде иерархической структуры с корнем. В таком представлении:

· Выделяется одна корневая вершина.
· Рёбра приобретают ориентацию "от корня" к нижележащим узлам.
· Вершины, не имеющие дочерних элементов, называются листьями.
· Каждый узел, кроме корня, имеет ровно одного родителя.

Такая структура идеально подходит для моделирования файловой системы, организации родословных или представления иерархических данных.

Что такое граф?

Граф — это абстрактная математическая модель, состоящая из множества вершин (узлов) и соединяющих их рёбер. Графы классифицируются по разным признакам:

· Ориентированные и неориентированные: В ориентированных графах ребра имеют направление (стрелки), в неориентированных — нет.
· Взвешенные и невзвешенные: Рёбрам взвешенного графа присваиваются числовые значения (вес), например, расстояние или стоимость.

Графы применяются для моделирования широкого спектра реальных систем: социальных связей, транспортных сетей, маршрутизации данных в интернете и многого другого.

Реализация структур данных на разных языках

Пример реализации дерева на Python

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.children = []

    def append_child(self, node):
        self.children.append(node)

# Использование
tree_root = Node("Root")
child_1 = Node("Child 1")
child_2 = Node("Child 2")
tree_root.append_child(child_1)
tree_root.append_child(child_2)
```

Анализ: Каждый узел хранит свои данные и список дочерних узлов. Этот подход прост для понимания и легко расширяется для реализации алгоритмов обхода.

Пример представления графа на Java

```java
import java.util.*;

class Vertex {
    private final String name;
    private Set<Vertex> adjacentVertices;

    public Vertex(String name) {
        this.name = name;
        this.adjacentVertices = new HashSet<>();
    }

    public void connectTo(Vertex other) {
        adjacentVertices.add(other);
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Vertex)) return false;
        return ((Vertex) obj).name.equals(this.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}

// Использование
Vertex v1 = new Vertex("V1");
Vertex v2 = new Vertex("V2");
v1.connectTo(v2);
v2.connectTo(v1);
```

Анализ: Класс Vertex представляет вершину графа. Для хранения соседей используется HashSet, что требует корректной реализации методов equals и hashCode для правильной работы.

Пример формирования графа на C++

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

struct Edge {
    int from;
    int to;
};

class Graph {
private:
    std::vector<std::vector<int>> adjacency_list;

public:
    Graph(int num_vertices) : adjacency_list(num_vertices) {}

    void addEdge(const Edge& edge) {
        adjacency_list[edge.from].push_back(edge.to);
        adjacency_list[edge.to].push_back(edge.from); // Для неориентированного графа
    }

    const std::vector<int>& getNeighbors(int vertex_id) const {
        return adjacency_list.at(vertex_id);
    }
};

// Пример использования
int main() {
    Graph g(3);
    g.addEdge({0, 1});
    g.addEdge({1, 2});
    for (auto n : g.getNeighbors(1)) {
        std::cout << n << ' ';
    }
    return 0;
}
```

Анализ: Граф реализован с использованием списка смежности (adjacency_list), где для каждой вершины хранится вектор её соседей. Это эффективный по памяти способ представления разреженных графов.

Алгоритм обхода дерева методом поиска в глубину (DFS)

Алгоритм поиска в глубину (Depth-first search, DFS) позволяет обойти все вершины дерева, начиная с корня, и двигаясь как можно "глубже" по каждому направлению, прежде чем вернуться.

Пример на Python

```python
def depth_first_search(start_node):
    visited_nodes = set()
    traversal_stack = [start_node]

    while traversal_stack:
        current_vertex = traversal_stack.pop()
        if current_vertex not in visited_nodes:
            visited_nodes.add(current_vertex)
            print(f"Вершина: {current_vertex.data}")
            traversal_stack.extend(reversed(current_vertex.children))
```

Описание шагов:

1. Инициализация: Процесс начинается с помещения корневой вершины в стек.
2. Извлечение и проверка: На каждом шаге из стека извлекается верхний элемент. Если эта вершина еще не посещалась, она обрабатывается (например, выводится на экран) и помечается как посещённая.
3. Добавление потомков: Все дочерние узлы текущей вершины добавляются в стек. Чтобы обойти детей в прямом порядке (слева направо), их добавляют в обратном порядке (благодаря reversed).
4. Завершение: Алгоритм завершает работу, когда стек становится пустым, что означает, что все достижимые вершины были обработаны.

Оценка производительности: Временная сложность алгоритма составляет O(N + M), где N — количество вершин, а M — количество рёбер. Это связано с тем, что каждая вершина посещается один раз, а каждое ребро просматривается для перехода к соседним вершинам.
