ПУНКТ 1)
Задание 1. Жадный алгоритм: размен монет
Условие. Даны номиналы монет и сумма S. Найти минимальное число монет для размена
(жадный подход).
Алгоритм: жадный выбор по наибольшему номиналу.
Язык примера: Python
def min_coins(coins, S):
coins.sort(reverse=True)
count = 0
for coin in coins:
# ДОПИСАТЬ: сколько монет номиналом coin можно взять
return count
Что дописать: цикл взятия максимального числа монет каждого номинала.

ПУНКТ 2)
Пошаговое описание кода.
1)Определение функции расчёта монет
Первый шаг кода реализовывает жадный алгоритм для поиска минимального числа монет: def min_coins(coins, S):

2)Сортировка номиналов
Следующий шаг кода упорядочивает монеты от наибольшего к наименьшему номиналу: coins.sort(reverse=True)

3)Перебор номиналов и расчёт монет
Этот шаг кода для каждого номинала берет максимально возможное число монет, чтобы уменьшить сумму: 
for coin in coins:
    if S >= coin:
        
4)Возврат результата
Далее код везвращает общее количество использованных монет: return count

5)Ввод данных пользователем
Этот шаг кода запрашивает от пользователя список номиналов и сумму для размена:
coins = list(map(int, input().split()))
S = int(input())

6)Вызов функции и вывод ответа
Последний шаш вычисляет и показывает минимальное число монет:
result = min_coins(coins, S)
print(f"Минимальное количество монет для размена: {result}")

ПУНКТ 3)
Временная сложность.
Временная сложность данного кода считается как O(n log n)

ПУНКТ 4)
Объяснение временной сложности.
Временная сложность алгоритма — O(n log n), где n — количество номиналов монет.
Это так, потому что главная затрата времени — сортировка номиналов (O(n log n)); остальной код выполняется за O(n).

ПУНКТ 5) 
1. Определение приближенных алгоритмов
Что такое приближенный алгоритм и какова его основная цель в решении NP-сложных задач?
Ответ: Приближённый алгоритм — это метод решения оптимизационных задач (особенно NP‑сложных), который за полиномиальное время находит не оптимальное, а достаточно хорошее решение с гарантированной оценкой точности: результат отличается от оптимума не более чем в p раз (для минимизации: A(I)<=p⋅OPT(I)). Его главная цель — обеспечить практическую разрешимость задач большого размера, для которых точное решение требует неприемлемо долгого времени вычислений.

