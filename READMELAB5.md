Вариант 3

1) Напишите рекурсивную функцию для нахождения наибольшего общего делителя
(НОД) двух чисел, используя алгоритм Евклида.

Алгоритм Евклида — это эффективный метод нахождения наибольшего общего делителя (НОД) двух чисел. Он основан на следующем математическом свойстве:

НОД(a, b) = НОД(b, a mod b), где a mod b — остаток от деления a на b

Процесс повторяется до тех пор, пока остаток не станет равным нулю. Когда остаток равен нулю, последний ненулевой остаток и есть НОД.

Пример работы алгоритма
Для чисел 56 и 98:

НОД(56, 98) = НОД(98, 56)   // 98 % 56 = 42
НОД(98, 56) = НОД(56, 42)   // 56 % 42 = 14
НОД(56, 42) = НОД(42, 14)   // 42 % 14 = 0
НОД(42, 14) = 14            // базовый случай (b = 0)
Результат: НОД(56, 98) = 14

Анализ сложности
Временная сложность: O(log(min(a, b)))

Объяснение пространственной сложности O(log(min(a, b))):

Пространственная сложность измеряет, сколько дополнительной памяти использует алгоритм в процессе выполнения. В случае рекурсивной реализации алгоритма Евклида:

Рекурсивные вызовы функции:

Каждый рекурсивный вызов функции gcd добавляет новый фрейм в стек вызовов

В каждом фрейме хранятся параметры функции, локальные переменные и адрес возврата

Глубина рекурсии:

Алгоритм Евклида гарантированно завершается за O(log(min(a, b))) шагов

Это связано с тем, что на каждом шаге числа уменьшаются примерно в 1.618 раз (золотое сечение)

В худшем случае (числа Фибоначчи) глубина рекурсии будет пропорциональна log₁.₆₁₈(min(a, b))

Математическое обоснование:

На каждой итерации: (a, b) → (b, a mod b)

Можно доказать, что a mod b < a/2 при a ≥ b

Таким образом, числа уменьшаются как минимум вдвое каждые 2 шага

Максимальное количество шагов: 2·log₂(min(a, b)) + 1

Пример:

Для чисел a = 100, b = 64:

gcd(100, 64) → gcd(64, 36) → gcd(36, 28) → gcd(28, 8) → gcd(8, 4) → gcd(4, 0)

Глубина рекурсии: 6 вызовов

log₂(min(100, 64)) ≈ log₂(64) = 6

Пространственная сложность: O(log(min(a, b))) из-за рекурсивных вызовов
Пространственная сложность O(log(min(a, b))) объясняется просто:

Каждый рекурсивный вызов функции gcd создает новый фрейм в стеке вызовов. Алгоритм Евклида гарантирует, что за каждые 2 шага числа уменьшаются как минимум вдвое. Поэтому глубина рекурсии (и количество фреймов в стеке) пропорциональна логарифму от меньшего числа.

Особенности реализации
Базовый случай: когда второй аргумент становится равным 0, возвращается первый аргумент

Рекурсивный вызов: функция вызывает саму себя с аргументами (b, a % b)

Обработка отрицательных чисел: можно добавить проверку на абсолютные значения

Порядок аргументов: алгоритм корректно работает независимо от порядка a и b

Почему наивная рекурсивная реализация чисел Фибоначчи неэффективна?
Наивная рекурсия Фибоначчи неэффективна, потому что:

Экспоненциальное время - сложность O(2ⁿ)

Повторные вычисления - одни и те же значения считаются много раз

Например, fib(5) вызывает fib(2) три раза, fib(3) два раза.

Эффективные альтернативы:

Динамическое программирование (снижает до O(n))

Мемоизация (кэширование результатов)

Итеративный подход

