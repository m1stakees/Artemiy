первый пункт) Алгоритмы. сортировки Блочная (корзинная) сортировка 

1) Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
   
2) Пример кода прикреплен в файл codesKP.py.
  
3) Сразу после кода прикреплен вывод консоли исходного кода.

4)Краткое объяснение блочной сортировки:
Основная идея:
Разбить элементы на группы по диапазонам значений, отсортировать каждую группу отдельно, затем объединить результаты.
Как работает:
Создание корзин - готовим несколько пустых контейнеров (корзин), каждая для определенного диапазона значений
Распределение по корзинам - каждый элемент помещаем в соответствующую корзину based на его значении:
for i, num in enumerate(arr):
        bucket_index = int(num * n)
        buckets[bucket_index].append(num)
        print(f"Число {num} добавлено в корзину {bucket_index}")

Сортировка корзин - каждую корзину сортируем отдельно (обычно простыми методами):
for bucket in buckets:
        bucket.sort()

Объединение - собираем все элементы из корзин в правильном порядке:
sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket)
    return sorted_arr

5)Оценка временной сложности алгоритма - O(n)

6) Краткое объяснение временной оценки сложности алгоритма.
O(n) - время распределения всех n элементов по соответствующим корзинам. Каждый элемент обрабатывается один раз.
O(k) - время работы с k корзинами (создание, обработка, объединение). Зависит от количества корзин.
Суммарно O(n + k) - общее время складывается из обработки всех элементов и всех корзин.
При оптимальном k ≈ n сложность стремится к O(n), так как каждая корзина содержит небольшое количество элементов и сортируется за постоянное время.

Второй пункт) Блинная сортировка.

1)Определение:Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.

2) Пример кода прикреплен в файл codesKP.py.
  
3) Сразу после кода прикреплен вывод консоли исходного кода.

4) Пояснение кода Блинной сортировки.
Основной цикл - постепенно уменьшаем неотсортированную часть:
for curr_size in range(n, 1, -1):

Цикл начинается с полного размера массива и уменьшается на 1 каждый раз, пока не останется 1 элемент.
max_idx = find_max_index(arr, curr_size)

Функция find_max_index находит позицию максимального элемента в текущей неотсортированной части массива.
if max_idx != curr_size - 1:
   if max_idx != 0:
        flip(arr, max_idx)
    flip(arr, curr_size - 1)

Если максимальный элемент не на своем месте:
Сначала переворачиваем часть массива до максимального элемента, чтобы он оказался в начале.
Затем переворачиваем всю неотсортированную часть, чтобы максимум оказался на правильной позиции:
def flip(arr, k):
    left = 0
    right = k
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
        
Функция flip переворачивает часть массива от индекса 0 до k, используя два указателя.

5) Временная сложность: O(n²)

6)Краткое объяснение временной оценки сложности:

n переворотов - внешний цикл выполняется n раз
Поиск максимума O(n) - каждый раз ищем максимум в неотсортированной части
Перевороты O(n) - каждый переворот требует до n операций
Итого: O(n × n) = O(n²) - так как для каждого из n элементов выполняем операции порядка n

Пункт 3. Сортировка бусинами(гравитационная).

1) Определение: Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году.

2) Пример кода прикреплен в файл codesKP.py.
  
3) Сразу после кода прикреплен вывод консоли исходного кода.

4)Объяснение кода сортировки бусинами:

Создается двумерный массив (абак), где строки представляют значения, а столбцы - элементы исходного массива:

abacus = [[0] * len(arr) for _ in range(max_val)]

Для каждого числа в массиве размещаем соответствующее количество бусин (единиц) в столбце:

for i, num in enumerate(arr):
    for j in range(num):
        abacus[j][i] = 1

В каждом ряду бусины "падают" влево, создавая отсортированные столбцы:

for i in range(len(abacus)):
    bead_count = sum(abacus[i])
    new_row = [1] * bead_count + [0] * (len(arr) - bead_count)
    abacus[i] = new_row

Подсчитываем количество бусин в каждом столбце - это и есть отсортированные значения:

for col in range(len(arr)):
    column_sum = sum(abacus[row][col] for row in range(max_val))
    result.append(column_sum)

5) Временная сложность - O(S)

6) S операций размещения - каждая бусина размещается отдельно
n × m операций гравитации - где n - длина массива, m - максимальное значение
S операций подсчета - подсчет бусин в столбцах
O(S) - общее время пропорционально сумме элементов.

Алгоритмы поиска.
Четвертый пункт) Поиск скачками (Jump search).

1) Определение: Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.

2) Пример кода прикреплен в файл codesKP.py.
  
3) Сразу после кода прикреплен вывод консоли исходного кода.

4) Объяснение кода поиска скачками:

Размер прыжка вычисляется как квадратный корень из длины массива - это оптимальный размер для минимизации количества сравнений.

step = int(math.sqrt(n))

Алгоритм прыгает через блоки, пока не найдет блок, где последний элемент больше или равен целевому значению.

while arr[min(step, n) - 1] < target:
    prev = step
    step += int(math.sqrt(n))

После нахождения нужного блока выполняется линейный поиск внутри этого блока.

while arr[prev] < target:
    print(f"Проверяем arr[{prev}] = {arr[prev]}")
    prev += 1

Финальная проверка - найденный элемент действительно равен целевому значению.

if arr[prev] == target:
    return prev

5) Оценка временной сложности - O(√n)

Краткое объяснение временной оценки сложности:

√n прыжков - количество прыжков пропорционально квадратному корню из n

√n сравнений в блоке - линейный поиск в блоке размером √n

Итого: O(√n + √n) = O(√n) - ссумарная сложность

Пятый пункт) Экспоненциальный поиск(Exponential Search)

1) Определение: Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

2) Пример кода прикреплен в файл codesKP.py.
  
3) Сразу после кода прикреплен вывод консоли исходного кода.

4) объяснение кода:
 Находим диапазон:

i = 1
while i < n and arr[i] <= target:
    i *= 2  # Удваиваем границу каждый раз

Бинарный поиск в диапазоне:

left = i // 2    # 16//2 = 8
right = min(i, n-1)  # min(16,13) = 13

5) Оценка временной сложности алгоритма - O(log n)

6) Краткое объяснение оценки временной сложности -
O(log k) + O(log k) = O(log k)

Но поскольку k ≤ n (позиция не больше размера массива), то:

Финальная оценка: O(log n)
